\documentclass[jou,apacite]{apa6}

\usepackage[utf8]{inputenc}
\usepackage[nonumberlist]{glossaries}
\usepackage{makeidx}

\makeglossaries
\loadglsentries{glossary}
\makeindex

\title{A short introduction to artificial intelligence}
\shorttitle{AI intro}

\author{Daniel Schruhl}
\affiliation{ThoughtWorks}

\abstract{A short introduction into the general topic of artificial intelligence. This should help address some aspects of artificial intelligence and define them on a shallow level to give a starting point into this topic.}

\begin{document}
\maketitle    
                        
\section{Motivation}
There are a lot of definitions for \gls{ai}. Most of them are based on a definition of intelligence which in itself is already difficult to define. A simple approach would be to say that humans cognitive functions (e.g. solving complex problems or learning) is considered intelligent. So making programs or machines pursue the way humans might solve problems or learn can be considered as \gls{ai}. These complex problems can be natural language processing, visual perception, motor control, planning or game theory.

\gls{ai} programs are sometimes also considered intelligent because from the outside their outcome appear to be magic. When actually developing the program itself and deep diving into the implementation, it leads to the realization of the often trivial nature of the implementation. This illustrates the possible paradox in \gls{ai}.

\gls{ai} can be used for image recognition, for controlling machines, to play games or to detect fraud. It can be used in nearly any domain and has already found great usage in medicine or commercial scenarios. Using \gls{ai} can give a company a major advantage against competitors. Companies like Netflix have embraced \gls{ai} \cite{Gomez-Uribe2015} and have established a market leading position also backed by \gls{ai}.

\section{Types of \gls{ai}}
Approaches to implement \gls{ai} have resulted into two major paradigms: \textbf{symbolic} and \textbf{sub-symbolic}. Symbolic approaches model a problem space with tokens or symbols that are humanly readable. This problem space is then processed by the \gls{ai} programs. The symbols themselves are therefore manipulated and processed. Because of the symbolic nature the \gls{ai} programs can be completely understood by humans. These programs are often called \gls{expert-system}, \gls{rules-engine}, \gls{knowledge-based-ai} or \gls{knowledge-graph}. They were the first paradigms that found usage in the past and are therefore also called \gls{gofai}. In theory they try to solve modeled problems in the same abstract way humans think and would solve problems.

The sub-symbolic paradigm also consists of symbols but they are not really human interpretable. These symbols represent more abstract components that can accomplish tasks suitable for \gls{ai} related tasks. The whole idea about this paradigm is to build the parts that make human cognitive functions possible on a more low level abstraction. It is highly inspired by biology (neurobiology, genetics, evolution) and psychology. This paradigm has found a lot of usage and popularity in the recent years.

\subsection{\gls{symbolic-ai}}
// TODO: Add example for expert system with symbols/logic

As stated before symbolic AI solves complex problems by using strategies researchers thought humans would also use. This is done by transforming a problem space into symbols and then applying functions on these symbols. The key here is coming up with an abstract model of the problem space and transforming it into symbols. Because of the nature of this paradigm, expert systems are easier to debug and understand and to control. A big disadvantage is that you need expert domain knowledge in order to solve the problem the way humans would do. Another advantage is though that big data is not needed.

Due to the symbolic nature \textbf{logic} can be used to solve complex problems. Logic consists of \textbf{semantic} and \textbf{syntax}. Syntax defines the representation of logics (symbols). It consists of an alphabet which forms words which in turn form language (\textbf{formulas}). This syntax is then interpreted by semantics. Semantics give meaning and interpretation to syntax and can be used to derive new formulas (\textbf{calculus}). This kind of system is called \textbf{formal system}. For more information about logics and formal systems see \cite{Richardson2006}. 

Formal systems have rules. These rules can be used to inference new rules or answer questions. This is often done by calculus (e.g. resolution calculus). Such a system of \gls{ai} can be built with \gls{prolog}.

Another important aspect of symbolic AI are \textbf{searches}. Often you have modeled a problem and try to find an answer in this problem space. This could be for example trying to find the perfect schedule for people with limited amount of time. Searches can be simple algorithms (breadth-first, depth-first) or \textbf{informed algorithms} (e.g. $A^*$). Informed algorithms use \textbf{heuristics} that try to estimate the best possible path inside a graph. This should lead to a faster search because some paths can be \textbf{pruned}. The intelligent part here lies in defining the heuristic.

Another aspect in searches is the \textbf{\gls{csp}}. In a \gls{csp} are \textbf{variables} which have value spaces (\textbf{domains}). Each variable is attached to \textbf{constraints}. These constrains can have multiple arity and define limitations for the domains. 
This way a net of variables and constraints is formed. The problem of solving the net and narrowing down the domains to a solution is the actual \gls{csp}. To solve these problems there are multiple algorithms (e.g. AC-3). \gls{csp} can be used to solve riddles or puzzles like Sudoku.

Searches can also be used to find paths from a start to a goal. This is called \textbf{planning}. In planning you have a state which describes a current situation. For the state there are possible moves that can be taken. Each move has a \textbf{condition}, \textbf{delete} and \textbf{add list}. Those lists can be used to test and execute the moves to change the state in order to pass the start state into the goal state. This kind of procedure can be used to control for example robotic arms. For more information see \gls{strips} and \cite{Nilsson1982}.

\subsection{\gls{sub-symbolic-ai}}
Sub-symbolic AI uses symbols in a more abstract way. The symbols become part of a low level system that is capable of cognitive functions. It is no longer possible to map concrete high level tasks like identifying objects in images directly to the symbols in the system. The output generated by sub-symbolic AI is therefore often probabilistic or approximated. This has led to more robust models that often showed better performance and scalability. Unfortunately most of these models need big data to get to that point. But these models are no longer bound to expert domain knowledge and have shown way better performance in tasks like visual perception. Sub-symbolic AI consists of machine learning, reinforcement learning and evolutionary computing.

\section{Machine learning}
Learning itself plays a huge part in cognitive functions. Learning essentially means incrementally improving performance on a given task. This implies that knowledge is represented in any form and incrementally more knowledge is generated or the already existing knowledge is hardened and diversified. Ways of achieving this would be by adding new data to that knowledge base or by adding time to extract more knowledge of the given data. Learning not only consists of extracting knowledge and retaining that knowledge of already learned data but also means handling new data and transferring already learned knowledge (by generalizing).

Machine learning accomplishes learning by doing pattern recognition in (big) data and generalizing these patterns. 
Programs that actually perform machine learning are called models. Models use input data and output data. The input data contains features. Input data is used to input into the model. Output data is data that should or is output by the model. Machine learning models generate knowledge implicitly by the features of the input data. Machine learning tasks can be grouped into supervised and unsupervised learning.

\subsection{Supervised learning}

\subsection{Unsupervised learning}

\subsection{\gls{connectionism}}
Connectionism tries to solve complex problems by modeling what we use to solve problems - our brain. Neurobiologically the brain consists on a low level of neurons that are connected. This can be modeled into a computer science abstraction. A neuron is 

\subsection{Deep learning}

\section{Reinforcement learning}
exploitation, exploration, thompson sampling, qlearning, sarsa

\section{Evolutionary computing}
genetic algorithm, genetic programming, evolutionary programming

\section{Big Data in context}

\section{Current state of AI and further topics}
 - capsule networks
 - autoencoders
 - attention mechanisms
 - gans
 - dqn
 - neat
 - neuroevolution

\section{Further readings}
deeplearning book

\printglossaries
\printindex
\bibliography{ai-intro-article}

\end{document}
